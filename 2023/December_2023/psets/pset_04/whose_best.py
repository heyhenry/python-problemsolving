"""
We wanna figure out who has the best name. Fortunately we have a perfect ordering of names (generated by
a magical AI), and just need a way to understand what it spits out. Then print out the best one!
File format: a series of lines of the form Name1 > Name2
Output: one of three things:
1. if a name is better than all others, then that name
2. if multiple names could be the best, then "UNKNOWN"
3. if there's a contradiction (Name1 > Name2, but Name2 > Name1), then "INVALID"
"""
import sys

def whose_best(filename : str):

    result = ''

    with open(filename, 'r') as file:

        read_content = file.read()

        if read_content:

            # a list that stores each line as an element
            sort_lines = read_content.splitlines()
            
            # breaks down each element in sort_lines into its own list of elements
            content = []

            for row in sort_lines:
                temp = row.split(' ')
                content.append(temp)

            # a unique list of names found in content
            names = []

            for row in content:
                for i in row:
                    if '>' not in i and '<' not in i and i not in names:
                        names.append(i) 
        
            # creating a rankings dictionary with the unique names as its keys
            rankings = {}

            for i in names:
                rankings[i] = []

            # allocating the appropriate names as values into respective keys (other names that were greater than said names)
            for row in content:
                for i in range(len(row)):
                    if row[i] == '>':
                        if row[i+1] not in rankings[row[i-1]]:
                            rankings[row[i-1]].append(row[i+1])

            new_rankings = {name: value.copy() for name, value in rankings.items()}

            for key, value in rankings.items():
                for s_key, s_value in rankings.items():
                    if key in rankings[s_key]:
                        for name in value:
                            new_rankings[s_key].append(name)

            # this finds the greatest name but does not know about contradictions or mulitple great names
            # this is the first hurdle of checks to validate the greatest name
            greatest_name = ''
            for key, value in new_rankings.items():
                if greatest_name == '':
                    greatest_name = key
                elif greatest_name in value:
                    greatest_name = key
            
            # this checks for invalids by way of seeing if the greatest_name is in any of the other key's values
            # it shouldnt be, so if it is then its considered invalid
            for key, value in new_rankings.items():
                if greatest_name in value:
                    result = 'Invalid'

            # checks key against the other key's values
            # if the key is found in another key's values, it means it isn't the greatest name
            # if the previous checks fail, then this kicks in to see if there are multiple 'great' names
            # aka, the key themselves are not found in any values
            # if there is more than 1 of such said keys, then it means there are potentially multiple great names
            # this by default means there is an anomaly present and we are unable to determine the greatest name, due to lack of data
            # so ultimately, the greatest name has to be considered as unknown
            counter = 0

            for key, value in new_rankings.items():
                temp_counter = 0
                for s_key, s_value in new_rankings.items():
                    # temporary counter to evaluate how many keys the given key is not present in
                    if key not in s_value:
                        temp_counter += 1
                # checks to validate whether the key is not in any of the other key's values
                if temp_counter == len(new_rankings):
                    counter += 1
            
            # final check for unknown hurdle
            # if there is more than 1 key that has no presence in other key's values
            # then there is not enough data to determine the greatest name
            if counter > 1:
                result = 'Unknown'

            # loops back to checking if either the 2nd or 3rd hurdles, invalid and unknown checks
            # were triggered, if neither was triggered, then it can be concluded that a great name
            # was found
            if result != 'Unknown' and result != 'Invalid':
                result = greatest_name

    return result 
        
def main():

    # print(whose_best(sys.argv[1]))

    print(whose_best('q3/input1.txt')) # Alice
    print(whose_best('q3/input2.txt')) # Invalid
    print(whose_best('q3/input3.txt')) # Unknown
    print(whose_best('q3/input4.txt')) # Alice
    print(whose_best('q3/input5.txt')) # Elmer
    print(whose_best('q3/input6.txt')) # Carol
    print(whose_best('q3/input7.txt')) # Invalid

if __name__ == "__main__":
    main()